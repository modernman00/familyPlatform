{"version":3,"file":"js/organogram.js","mappings":";;;;;;;;;;;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAKA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AAEA;AACA;AAAA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AA9BA;AAAA;AAQA;AAsBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAMA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAAA;AAAA;AAmBA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAOA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AASA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEzRA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAIA;AAGA;AAIA;AACA;AAEA;AAAA;AAAA;AAGA;AAAA;AAGA;AAEA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAtCA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtGA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AAEA;AAGA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAQA;AAEA;AACA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAAA;AAAA;AAmBA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnNA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAEA;;AAEA;AAEA;AAWA;;AAEA;;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AAEA;AAGA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AAGA;AACA;AAEA;AAEA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;;AAgBA","sources":["webpack://family/./resources/asset/js/components/FormHelper.js","webpack://family/./resources/asset/js/components/familyTree/index.js","webpack://family/./resources/asset/js/components/global.js","webpack://family/./resources/asset/js/components/helper/general.js","webpack://family/./resources/asset/js/components/navbar.js"],"sourcesContent":["'use strict'\n\nimport { matchRegex } from \"./helper/general\"\n\nexport default class FormHelper {\n    constructor(data) {\n         if (!Array.isArray(data)) throwError('data must be an array of form elements');\n        this.data = data;\n        this.error = [];\n        this.result = 0;\n    }\n\n    id(x) {\n        return document.getElementById(x)\n    }\n\n    /**\n     * general validation; check empty status, at least a single input, mobile length, white space\n     */\n\n    getData() {\n        return this.data;\n    }\n\n\n    validateField(value, type = 'general') {\n        const regexes = {\n            email: /^[\\w\\-\\.\\+]+\\@[a-zA-Z0-9\\.\\-]+\\.[a-zA-Z0-9]{2,4}$/,\n            // Add more regexes as needed\n        };\n        return type === 'email' ? regexes.email.test(value) : value.trim() !== '';\n    }\n\n\n    massValidate() {\n        // const reg = /[a-zA-Z0-9./@]/g;\n        this.data.forEach(et => {\n\n            for (let post of et) {\n                // capture the error to a variable\n                let errMsg = this.id(`${post.name}_error`)\n                let postName = post.name.replace('_', ' ')\n                let asterisk = \"*\";\n\n                // rid it off the submit and token\n                if (['submit', 'button', 'showPassword_id', 'g-recaptcha-response', 'cancel', 'token', 'checkbox_id'].includes(post.name) ||\n                    ['button'].includes(post.id) || ['button'].includes(post.type)) return;\n                // check if there is no value\n\n                if (['spouseName', 'spouseMobile', 'spouseEmail', 'fatherMobile', 'fatherEmail', 'motherMobile', 'maidenName', 'motherEmail'].includes(post.name)) {\n                    // post.value is not prpvided if it is not provided \n                    post.value = post.value === \"\" ? \"Not Provided\" : post.value\n                }\n\n                if (post.value === '' || post.value === 'select') {\n                    if (!this.validateField(post.value)) {\n                        if (errMsg) {\n                            errMsg.innerHTML = `${post.placeholder ?? asterisk} cannot be left empty`;\n                            errMsg.style.color = 'red';\n                        }\n                        this.error.push(`${postName.toUpperCase()} cannot be left empty`);\n                        this.result = false;\n                    }\n                }\n\n                if (post.name === 'email' && !this.validateField(post.value, 'email')) {\n                    this.error.push('<li style=\"color: red;\">Please enter a valid email</li>');\n                    if (errMsg) errMsg.innerHTML = '* Please enter a valid email';\n                    this.result = false;\n                }\n            }\n        })\n    }\n\n    emailVal() {\n        const emailExp = /^[\\w\\-\\.\\+]+\\@[a-zA-Z0-9\\.\\-]+\\.[a-zA-z0-9]{2,4}$/;\n        let msg = `<li style=color:'red';> Please enter a valid email</li>`\n        const email = this.id('email_id').value\n        if (email.match(emailExp) === null) {\n            this.id('email_error').innerHTML = msg\n            this.id('email_error').style.color = \"red\"\n            this.error.push(msg)\n        }\n    }\n\n    clearError() {\n        this.error = []; // Empty the error array\n\n        // Define a function to clear error messages for a given input element\n        const clearErrorForElement = (elementName) => {\n            const errorElement = this.id(`${elementName}_error`);\n            if (errorElement) {\n                errorElement.innerHTML = '';\n            }\n        };\n\n\n        this.data.forEach(el => {\n            for (let post of el) {\n\n\n\n                const { id, name, value } = post;\n\n                // Skip certain input types\n                if (['submit', 'button', 'token', 'checkbox'].includes(id) || ['token', 'submit'].includes(name)) {\n                    continue;\n                }\n\n                const the_id = this.id(id);\n\n\n                if (the_id) {\n                    // Add keyup event listener to clear errors for non-select inputs\n                    the_id.addEventListener('keyup', () => {\n                        if (value !== 'select') {\n                            clearErrorForElement(name);\n                        }\n                    });\n                } else {\n                    console.error(`Element with ID '${id}' with post name '${post.name}' not found.`);\n                }\n\n                // Add change event listener to clear error message\n                the_id.addEventListener('change', () => {\n                    clearErrorForElement(name);\n                });\n\n            }\n        })\n    }\n\n    clearHtml() {\n\n        this.data.forEach(el => {\n            for (let post of el) {\n                if (post.id == 'submit' || post.name == 'submit' || post.name == 'checkbox') {\n                    continue\n                }\n                post.value = \"\"\n\n\n            }\n        })\n    }\n\n    /**\n     *\n     * @param {input is the id of the input/ this is an array [as, it, it]} input\n     * @param {* this is the max policy and it must be an integer} maxi\n     */\n\n    realTimeCheckLen(input, maxi) {\n        try {\n            for (let i = 0; i < input.length; i++) {\n                const theData = this.id(`${input[i]}_id`);\n                if (theData === null || theData === undefined || theData === \"\") {\n                    throw new Error(`Element with ID '${input[i]}_id' not found or is empty`);\n                }\n                const max = maxi[i];\n                const error = this.id(`${input[i]}_error`);\n                theData.maxLength = parseInt(max) + 1; // Fixed the parsing issue here\n                theData.addEventListener('keyup', () => {\n                    error.innerHTML = (theData.value.length > max) ? `You have reached the maximum limit` : \"\";\n                    const help = this.id(`${input[i]}_help`);\n                    help.style.color = 'red';\n                    help.style.fontSize = '10px';\n                    error.style.color = 'red';\n                    setTimeout(() => {\n                        help.style.display = 'none';\n                    }, 5000);\n                });\n            }\n        } catch (error) {\n            console.error(error.message);\n        }\n    }\n\n\n    /**\n     * the id for the password error should be password_help\n     * the id for your confirm pasword should confirm_password\n     * it will return an error message to the password_help input\n     */\n\n    matchInput(first, second) {\n        let error, firstInput, secondInput\n        error = this.id(`${second}_error`)\n        firstInput = this.id(first + '_id')\n        secondInput = this.id(second + '_id')\n        secondInput.addEventListener('keyup', () => {\n            error.innerHTML = (secondInput.value !== firstInput.value) ? 'Your passwords do not match' : \"\"\n        })\n    }\n    /**\n     *\n     * @param {the id of the input you want to inject to/ this is an array} idArray\n     * @param {*the comment or questions you want o inject} html\n     */\n\n    injectData(idArray, html) {\n        let idData;\n        for (let i = 0; i < idArray.length; i++) {\n            idData = this.id(idArray[i]);\n            idData.innerHTML = html[i];\n        }\n    }\n\n    /**\n     *\n     * @param {this is an id and its value is for duplication} firstInput\n     * @param {* another id that accepts the value of the firstInput} takeFirstInput\n     */\n    duplicate(giveInput, takeInput) {\n        let giver, taker;\n        giver = this.id(giveInput)\n        taker = this.id(takeInput)\n        giver.addEventListener('keyup', () => {\n            taker.value = giver.value;\n        })\n    }\n\n    /**\n     *\n     * @param {current input that is being type to. the value is what will be checked realtime. the id is needed} input\n     * @param {* the url to get the info to . example is /search?hint} url\n     * @param {enter the id of the output element} output\n     */\n\n\n    realTimeServer(input, url, outputId) {\n        let theInput, inputVal, output;\n        theInput = this.id(input)\n        output = this.id(outputId)\n        theInput.addEventListener('keyup', () => {\n            inputVal = theInput.value\n\n            if (inputVal == 0) {\n                output.innerHTML = \"\";\n                return;\n            } else {\n                var xmlhttp = new XMLHttpRequest();\n                xmlhttp.onreadystatechange = function () {\n                    if (this.readyState == 4 && this.status == 200) {\n                        output.innerHTML = this.responseText;\n                    }\n                }\n                xmlhttp.open(\"GET\", `${url}=${inputVal}`, true);\n                xmlhttp.send();\n            }\n        })\n    }\n\n    isChecked(yesId, noId, hiddenInput) {\n        const checked = () => {\n            if (this.id(yesId).checked) {\n                alert('check')\n                this.id(hiddenInput).innerHTML = 'checked';\n            } else if (this.id(noId).checked) {\n                this.id(hiddenInput).innerHTML = 'checked';\n            }\n        }\n\n        this.id(yesId).addEventListener('click', checked)\n        this.id(noId).addEventListener('click', checked)\n\n    }\n\n    previousAddress() {\n        const timeAddy = this.id('time_at_address_id')\n        const prevAddy = this.id('previous_address_class')\n        const showPrev = () => {\n            if (timeAddy.value != '3 years+') {\n                prevAddy.style.display = 'block'\n                this.id('previous_address_help').innerHTML = \"Please enter your full address: House No, Street Name, Town/City and Post Code\"\n            } else {\n                prevAddy.style.display = 'none'\n            }\n\n        }\n        timeAddy.addEventListener('change', showPrev)\n\n    }\n\n\n}","import \"../navbar\"","import axios from \"axios\"\n\nexport const id = (id) => document.getElementById(id)\nexport const idValue = (id) => id(id).value\nexport const idInnerHTML = (id) => id(id).innerHTML\nexport const warningSign = \"\\u26A0\"; // danger warning sign\n\nexport const qSel = (name) => document.querySelector(name)\nexport const qSelAll = (name) => document.querySelectorAll(name)\nexport const qSelValue = (name) => qSel(name).value\nexport const qSelInnerHTML = (name) => qSel(name).innerHTML\n\nexport const log = (id, identifier =null) => {\n    console.log(' start'+ \"  \" + identifier)\n    console.log(id)\n    console.log(' end'+ \"  \" +identifier)\n}\nexport const write = (input) => document.write(input)\n\nexport const hideElement = (elementId) => {\n  id(elementId).style.display = \"none\";\n};\n\nexport const showElement = (elementId) => {\n  id(elementId).style.display = \"block\";\n};\n\nexport const manipulateAttribute = (idName, removeOrSet, attributeType, nameValue =null) => {\n\n    if(removeOrSet === \"remove\") {\n           id(idName).removeAttribute(attributeType)\n    } else {\n        id(idName).setAttribute(attributeType, nameValue)\n    }\n \n  \n}\n\nexport const date2String = (date) => new Date().toDateString(date)\n\nexport const showError = (e) => {\n  \n    log(e.message, \" ERROR MESSAGE\") // \"null has no properties\"\n    log(e.name, \" ERROR NAME\") // \"TypeError\"\n    log(e.fileName,  \" ERROR FILENAME\") // \"Scratchpad/1\"\n    log(e.lineNumber, \" ERROR LINENUMBER\") // 2\n\n    log(e.stack)\n}\n\nexport const msgException = (errorMessage) => {\n  \n    throw new Error(errorMessage)\n}\n\n\n/**\n * \n * @param {*} elementId - element id\n * @param {*} addClass either a success or danger class (green or red)\n * @param {*} message - html message to convey success or failure\n * @param {*} timer - timer for the message to disappear- default is 5 secs\n */\nexport const showNotification = (elementId, addClass, message, timer = 5000) => {\n    // display the success information for 10sec\n    id(`${elementId}`).style.display = \"block\" // unblock the notification\n    id(`${elementId}`).classList.add(addClass) // add the success class\n    id(`${elementId}`).innerHTML = message // error element\n    id('loader').classList.remove('loader') // remove loader\n\n    setTimeout(() => {\n        id(`${elementId}`).style.backgroundColor = \"\"\n        id(`${elementId}`).style.color = \"\"\n        id(`${elementId}`).innerHTML = \"\"\n    }, timer)\n}\n\n    // Function to check for elements and render if they exist\n    export const checkElements = (idOrClass, classString, theFunction = null) => {\n\n        const doesElementExist = (idOrClass === \"id\") ? id(classString) : qSel(classString)\n        // Check if elements exist before calling render function\n        if (doesElementExist.length) {\n            theFunction(doesElementExist);\n        }\n\n    };\n\n     export const checkManyElements = (idOrClass, classString, theFunction = null) => {\n\n        const doesElementExist = (idOrClass === \"id\") ? id(classString) : qSelAll(classString)\n        // Check if elements exist before calling render function\n        if (doesElementExist.length > 0) {\n            theFunction(doesElementExist);\n        }\n\n    };\n\n    const yourId = localStorage.getItem('requesterId');\n    const famCode = localStorage.getItem('requesterFamCode');\n\n    // delete notification \n    export const deleteNotification = async (elementId) => {\n\n         // Extract the user ID from the target ID\n            const senderId = elementId.replace(\"deleteNotification\", \"notificationBar\");\n          \n            const elementData = id(elementId)\n            const data = elementData.getAttribute(\"data-id\");\n\n            // change the background of the clicked element \n\n            const notificationHTML = id(senderId);\n\n            // Make sure required variables are defined before using them\n            if (\n                typeof yourId === 'undefined' ||\n                typeof famCode === 'undefined'\n            ) {\n                msgException(\"Required parameters (yourId or famCode) are not defined\");\n            }\n\n            const url = `/removeNotification/${yourId}/${famCode}/${data}`\n\n\n            const response = await axios.put(url)\n\n\n            if (response.data.message === \"Notification marked as read\") {\n\n                // remove a html element with notificationBar after 2 mins \n                notificationHTML.remove()\n\n                // reduce the notification count as you have deleted the notification\n\n                const newValues = parseInt(sessionStorage.getItem('notificationCount') - 1)\n                id('notification_count').innerHTML = newValues;\n            } else {\n                msgException(\"Error removing notification\" + \" \" + response.data.message);\n            }\n    }","\"use strict\";\nimport { id, qSelAll } from '../global';\nimport autocomplete from 'autocompleter';\nimport FormHelper from '../FormHelper';\n\n\nexport const loaderIconBootstrap = () => {\n\n    return `<div class=\"spinner-grow text-primary\" role=\"status\">\n        <span class=\"sr-only\">Loading...</span>\n        </div>`\n}\n\nexport const loaderIcon = () => {\n\n    return `<div class=\"loader\"></div>`\n}\n\nexport const loaderIconBulma = () => {\n\n    return `<div class=\"is-loading\"></div>`\n}\n\nexport const removeDiv = (div_id) => {\n    const div = document.getElementById(div_id)\n    if (div) {\n        return div.remove()\n    }\n\n}\n\n\n\nexport const createAndAppendElement = (elementType, setId, parent, setClass = null) => {\n    const newDiv = document.createElement(elementType);\n    newDiv.setAttribute('id', setId)\n    newDiv.setAttribute('class', `field ${setClass}`)\n    const parentDiv = id(parent)\n    return parentDiv.appendChild(newDiv)\n}\n\n/**\n * \n * @param {the id of the input} inputId \n * @param {the api data or array data} data \n * @param { filterby is the data.filterby }\n */\nexport const autoCompleter = (inputId, data) => {\n    autocomplete({\n        input: inputId,\n        fetch: function (text, update) {\n            text = text.toLowerCase();\n            // you can also use AJAX requests instead of preloaded data\n            const suggestions = data.filter(n => n.firstName.toLowerCase().startsWith(text))\n            update(suggestions);\n        },\n        onSelect: function (item) {\n            input.value = item.firstName;\n        }\n\n    })\n}\n\nexport const distinctValue = (array) => {\n    return [...new Set(array)]\n}\n\nexport const checkBox = (subject) => {\n    return `<div class=\"control\"> \n        <label class=\"radio\">\n          <input type=\"radio\" name=\"send${subject}\" value=\"yes\" id=${subject}Yes > Yes \n        </label>\n        <label class=\"radio\"> \n          <input type=\"radio\" name=\"send${subject}\" value=\"no\" id=${subject}No checked> No \n        </label>\n      </div>`;\n}\n\nexport const checkBox2 = (subject) => {\n    return `<div class=\"control\"> \n        <label class=\"checkbox\">\n          <input type=\"checkbox\" name=\"send${subject}\" value=\"yes\" id=${subject}Yes> Yes \n        </label>\n        <label class=\"checkbox\"> \n          <input type=\"checkbox\" name=\"send${subject}\" value=\"no\" id=${subject}No> No \n        </label>\n      </div>`\n\n}\n\nexport const isChecked = (name, fn) => {\n    const yesId = (`${name}Yes`)\n    const noId = `${name}No`\n    const checked = () => {\n        if (id(yesId).checked) {\n            alert('check')\n            fn()\n        } else if (id(noId).checked) {\n            alert('check No')\n        }\n    }\n    id(yesId).addEventListener('click', checked)\n    id(noId).addEventListener('click', checked)\n}\n\nexport const matchRegex = (data) => {\n    if (data) {\n        if (data != \"Not Provided\") {\n            const regex = /[<?/>]+/g\n            const result = data.match(regex)\n            if (result === null) return true\n        }\n    }\n}\n\n/**\n * \n * @param { id of the first element} first \n * @param {* id of the second element} second \n * @param {* error id - if error - where to show it} err \n */\nexport const matchInput = (first, second, err) => {\n    let error, firstInput, secondInput\n    error = id(err)\n    firstInput = id(first)\n    secondInput = id(second)\n\n    secondInput.addEventListener('keyup', () => {\n\n        if (secondInput.value !== firstInput.value) {\n            error.innerHTML = 'Your passwords do not match'\n            error.style.color = \"red\"\n        } else {\n            error.innerHTML = \"The password is matched: <i class='fa fa-check' aria-hidden='true'></i>\"\n            error.style.color = \"green\"\n        }\n\n\n    })\n}\n\n/**\n * Converts a string to sentence case.\n *\n * Sentence case is a string where the first letter of each word is capitalized, and the rest of the letters are in lowercase.\n *\n * @param {string} str The string to convert to sentence case.\n * @returns {string} A new string in sentence case.\n */\nexport const toSentenceCase = (str) => {\n    return str\n        .toLowerCase() // Convert the string to lowercase\n        .split(' ')    // Split the string into words\n        .map(word => word.charAt(0).toUpperCase() + word.slice(1)) // Capitalize the first letter of each word\n        .join(' ');    // Join the words back into a string\n}\n\nexport const convertFormData = (formId) => {\n    const formInput = qSelAll(formId)\n    const formInputArr = Array.from(formInput)\n    return new FormHelper(formInputArr)\n\n}\n\n\n\nexport const showResponse = (theId, message, status) => {\n    const responseEl = id(theId)\n    const col = status ? 'green' : 'red'\n\n    responseEl.innerHTML = message\n    responseEl.style.color = 'green'\n    responseEl.style.backgroundColor = col\n    responseEl.style.color = 'white';\n    setTimeout(() => {\n        responseEl.innerHTML = '';\n    }, 5000); // Disappear after 5 seconds\n\n}\n\n\n/**\n   *\n   * @param {input is the id of the input/ this is an array [as, it, it]} input\n   * @param {* this is the max policy and it must be an integer} maxi\n   */\n\nexport const realTimeCheckLen = (input, maxi) => {\n    try {\n        for (let i = 0; i < input.length; i++) {\n            const theData = id(`${input[i]}_id`);\n            if (theData === null || theData === undefined || theData === \"\") {\n                throw new Error(`Element with ID '${input[i]}_id' not found or is empty`);\n            }\n            const max = maxi[i];\n            const error = id(`${input[i]}_error`);\n            theData.maxLength = parseInt(max) + 1; // Fixed the parsing issue here\n            theData.addEventListener('keyup', () => {\n                error.innerHTML = (theData.value.length > max) ? `You have reached the maximum limit` : \"\";\n                const help = id(`${input[i]}_help`);\n                help.style.color = 'red';\n                help.style.fontSize = '10px';\n                error.style.color = 'red';\n                setTimeout(() => {\n                    help.style.display = 'none';\n                }, 5000);\n            });\n        }\n    } catch (error) {\n        console.error(error.message);\n    }\n}\n\n\n","import { format, render } from \"timeago.js\"\nimport { id, showError, qSel, log, msgException } from './global'\nimport { toSentenceCase } from \"./helper/general\"\n\n// const timeAgo = (x) => format(x)\nimport axios from \"axios\"\n// import { html } from './profilePage/html';\n\n \n        // Update notification badge\n        function updateNotificationBadge(change) {\n            const badge = document.querySelector('.notification-badge');\n            let count = parseInt(badge.textContent);\n            count += change;\n            if (count <= 0) {\n                badge.style.display = 'none';\n            } else {\n                badge.textContent = count;\n                badge.style.display = 'flex';\n            }\n        }\n\n\nconst postAgoNotification = (date) => {\n    return `\n  <div class=\"notification_timeago w3-left w3-opacity\" datetime='${date}' title='${format(date)}'> ${format(date)}\n  </div>`\n}\n// this is the notification htnl \nconst notificationHTML = (data) => {\n\n    // generate random numbers to make the notification unique\n\n    let randomNumber = Math.floor(100 + Math.random() * 900);\n\n    return `<a id = \"notificationBar${data.sender_id}${randomNumber}\" data-id=\"${data.sender_id}\" class=\"w3-bar-item w3-button notification_real_time linkRequestCard w3-padding-16\">\n\n        ${postAgoNotification(data.created_at)}  - \n        <b> ${data.notification_type}</b> -\n        ${data.notification_name} -\n        ${data.notification_content} -\n        ${toSentenceCase(data.sender_name)}\n        <button type = \"submit\" class='w3-button-small w3-round w3-hover-grey w3-border-blue' data-id=\"${data.sender_id}\" id=\"deleteNotification${data.sender_id}${randomNumber}\"> delete</button>\n  </a>\n\n  `\n}\n\n// CLICK FUNCTION ON THE NOTIFICATION BAR THAT TAKES ONE TO THE FRIEND REQUEST CARD\n\nexport const increaseNotificationCount = () => {\n    const currentNotificationCount = parseInt(\n        sessionStorage.getItem('notificationCount')) + 1\n\n    id('notification_count').innerHTML = currentNotificationCount\n}\n\nexport const addToNotificationTab = (data) => {\n\n    return qSel('.notification_tab').insertAdjacentHTML('afterbegin', notificationHTML(data));\n\n}\n\n\nconst yourId = localStorage.getItem('requesterId');\nconst famCode = localStorage.getItem('requesterFamCode');\nconst notificationURL = `/member/notifications/id/${yourId}/${famCode}`;\n\n\n// get all the notification and display them \n// they are already filtered by famCode and id \n// for the family request, connection is done by id\n// for events -birthday etc, the connection is the famCode \n// so linked notification will be either where id matches or famcode matches\n\naxios.get(notificationURL)\n    .then(res => {\n\n        // Extract the notifications from the response\n        const data = res.data.message;\n\n        if (data) {\n\n            if (data.length > 0) {\n\n                // Display the count of notifications\n                id('notification_count').innerHTML = data.length;\n\n                // Store the notification count in session storage\n                sessionStorage.setItem('notificationCount', data.length);\n\n                // Display each notification\n                data.forEach(element => {\n                    addToNotificationTab(element);\n                });\n\n                // Update the timing of notifications\n                const updateNotificationTiming = document.querySelectorAll(\".notification_timeago\");\n                render(updateNotificationTiming);\n            } else {\n                id('notification_count').innerHTML = 0;\n            }\n\n        }\n\n\n    })\n    .catch(error => {\n        // Handle any errors that occur during the process\n        showError(error);\n    });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n///member/notifications"],"names":[],"sourceRoot":""}